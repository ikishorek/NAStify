diff -Nur a/Pods/LTHPasscodeViewController/LTHPasscodeViewController/LTHKeychainUtils.m b/Pods/LTHPasscodeViewController/LTHPasscodeViewController/LTHKeychainUtils.m
--- a/Pods/LTHPasscodeViewController/LTHPasscodeViewController/LTHKeychainUtils.m	2014-10-28 21:09:23.000000000 +0100
+++ b/Pods/LTHPasscodeViewController/LTHPasscodeViewController/LTHKeychainUtils.m	2014-10-28 18:52:22.000000000 +0100
@@ -38,6 +38,23 @@
 
 @implementation LTHKeychainUtils
 
++ (NSString *)keychainAccessGroup {
+	NSDictionary *query = [NSDictionary dictionaryWithObjectsAndKeys:
+						   (__bridge id)(kSecClassGenericPassword), kSecClass,
+						   @"bundleSeedID", kSecAttrAccount,
+						   @"", kSecAttrService,
+						   (id)kCFBooleanTrue, kSecReturnAttributes,
+						   nil];
+	CFDictionaryRef result = nil;
+	OSStatus status = SecItemCopyMatching((__bridge CFDictionaryRef)query, (CFTypeRef *)&result);
+	if (status == errSecItemNotFound)
+		status = SecItemAdd((__bridge CFDictionaryRef)query, (CFTypeRef *)&result);
+	if (status != errSecSuccess)
+		return nil;
+	NSString *accessGroup = [(__bridge NSDictionary *)result objectForKey:(__bridge_transfer NSString *) kSecAttrAccessGroup];
+	CFRelease(result);
+	return accessGroup;
+}
 
 + (NSString *) getPasswordForUsername: (NSString *) username andServiceName: (NSString *) serviceName error: (NSError **) error {
 	
@@ -55,6 +72,10 @@
 	NSArray *keys = [[NSArray alloc] initWithObjects: (__bridge_transfer NSString *) kSecClass, kSecAttrAccount, kSecAttrService, nil];
 	NSArray *objects = [[NSArray alloc] initWithObjects: (__bridge_transfer NSString *) kSecClassGenericPassword, username, serviceName, nil];
 	NSMutableDictionary *query = [[NSMutableDictionary alloc] initWithObjects: objects forKeys: keys];
+
+#if TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+	[query setObject:[self keychainAccessGroup] forKey: (__bridge_transfer NSString *) kSecAttrAccessGroup];
+#endif
 	// First do a query for attributes, in case we already have a Keychain item with no password data set.
 	// One likely way such an incorrect item could have come about is due to the previous (incorrect)
 	// version of this code (which set the password as a generic attribute instead of password data).
@@ -179,8 +200,11 @@
 			
 			NSArray *objects = [[NSArray alloc] initWithObjects: (__bridge_transfer NSString *) kSecClassGenericPassword,serviceName,serviceName,username,nil];
 			
-			NSDictionary *query = [[NSDictionary alloc] initWithObjects: objects forKeys: keys];
-			
+			NSMutableDictionary *query = [[NSMutableDictionary alloc] initWithObjects: objects forKeys: keys];
+#if TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+			[query setObject:[self keychainAccessGroup] forKey:(__bridge_transfer NSString *) kSecAttrAccessGroup];
+#endif
+
 			status = SecItemUpdate((__bridge CFDictionaryRef) query, (__bridge CFDictionaryRef) [NSDictionary dictionaryWithObject: [password dataUsingEncoding: NSUTF8StringEncoding] forKey: (__bridge_transfer NSString *) kSecValueData]);
 		}
 	}
@@ -195,8 +219,11 @@
 		
 		NSArray *objects = [[NSArray alloc] initWithObjects: (__bridge_transfer NSString *) kSecClassGenericPassword,serviceName,serviceName,username,[password dataUsingEncoding: NSUTF8StringEncoding],nil];
 		
-		NSDictionary *query = [[NSDictionary alloc] initWithObjects: objects forKeys: keys];
+		NSMutableDictionary *query = [[NSMutableDictionary alloc] initWithObjects: objects forKeys: keys];
 		
+#if TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+		[query setObject:[self keychainAccessGroup] forKey:(__bridge_transfer NSString *) kSecAttrAccessGroup];
+#endif
 		status = SecItemAdd((__bridge CFDictionaryRef) query, NULL);
 	}
 	if (error != nil && status != noErr)
@@ -224,7 +251,10 @@
 	}
 	NSArray *keys = [[NSArray alloc] initWithObjects: (__bridge_transfer NSString *) kSecClass, kSecAttrAccount, kSecAttrService, kSecReturnAttributes, nil];
 	NSArray *objects = [[NSArray alloc] initWithObjects: (__bridge_transfer NSString *) kSecClassGenericPassword, username, serviceName, kCFBooleanTrue, nil];
-	NSDictionary *query = [[NSDictionary alloc] initWithObjects: objects forKeys: keys];
+	NSMutableDictionary *query = [[NSMutableDictionary alloc] initWithObjects: objects forKeys: keys];
+#if TARGET_OS_IPHONE && !TARGET_IPHONE_SIMULATOR
+	[query setObject:[self keychainAccessGroup] forKey:(__bridge_transfer NSString *) kSecAttrAccessGroup];
+#endif
 	OSStatus status = SecItemDelete((__bridge CFDictionaryRef) query);
 	
 	if (error != nil && status != noErr)
